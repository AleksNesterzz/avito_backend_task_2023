# Что использовал
- БД: PostgreSQL (драйвер pq)
- Роутер: chi
- Тестирование: testify и mock
- Чтение конфига: cleanenv
- Развертиывание приложения: Docker
# Структура проекта
- cmd в нем находится main файл, который инициализирует конфиг, БД, запускает сервер и обработчики
- internal вся внутренняя кухня
- internal/config конфигурационный файл и его парсер
- internal/http-server/handlers - обработчики запросов
- internal/storage - ошибки связанные с базой данных
- storage/postgres - запросы к БД
- scripts содержит shell-скрипт для ожидания поднятия БД в контейнере перед тем, как к нему подключится контейнер приложения
# Сборка и запуск проекта происходит с помощью команды   
`docker build -t go-app . && docker-compose up --build go-app`
# Для запуска тестов тестов можно воспользоваться командой   
 `docker-compose run go-app go test ./.../tests`
# Что было сделано
- При инициализации БД происходит создание двух таблиц, нужных для работы API, если они еще не были созданы
- 5 методов:
   - POST-запрос для создания нового сегмена (принимает на вход название сегмента)
   - Delete-запрос для удаления сегмента (принимает на вход название сегмента)
   - Patch-запрос для обновления информации о сегментах пользователя (на вход - добавляемые сегменты, удаляемые сегменты и ID пользователя) Я не стал делать ограничение на ID пользователя по внешнему ключу, так как не стал делать отдельную таблицу для пользователей(в задании этого написано не было)
   - Get-запрос для получения информации о сегментах пользователя(на вход ID пользователя)
   - Get-запрос для получения истории пользователя (на вход ID пользователя и дата в формате "YYYY-MM") на выходе ссылка на локальный файл на компьютере (Скорее всего лучшим решением для создания ссылки было бы создание файла, загрузка его на какой-то сервис, например Google Disc, и потом уже сделать ссылку от этого сервиса). Получить информацию из этого файла можно через
  `docker exec -it <ID контейнера> bash`
- Также к этим 5 методам были написаны unit-тесты
# ПРИМЕРЫ ЗАПРОСОВ
